{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/04/08/hello-world/"},{"title":"我的第一篇文章","text":"一直一来就想记录一下自己的生活、想法和学到的技术。自己经常会出现学到的东西总是忘，有些拿来一用的东西每次去找都会去花费很多时间，下次需要还得找。索性就用博客这种形式记录吧。 希望自己能坚持记录，更好的完善这个博客吧，加油！","link":"/2020/04/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"title":"1050.螺旋矩阵 (25分)-PAT乙级","text":"1050 螺旋矩阵 (25分) 本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。 输入格式：输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。 输出格式：输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。 输入样例：121237 76 20 98 76 42 53 95 60 81 58 93 输出样例：123498 95 9342 37 8153 20 7658 60 76 分析：N=m x n其中m&gt;=sqrt(N)&gt;=n，所以让m、n=sqrt(N)，若此时m x n&lt;N则m++，m x n&gt;N则n–，若m x n=N则找到满足条件的m、n。申请m x n数组，将排序号的数组元素按以下方式填入（状态机思想）：定义四种状态（UP\\DOWN\\LEFT\\RIGHT）检测条件转变状态。题目中的矩阵是顺时针填充，即遍历方向是 起点 -&gt; 向右填充 -&gt; 向下填充 -&gt; 向左填充 -&gt; 向上填充 -&gt; 向右填充…循环往复，全部填满时结束。当我们完成每一个横向或竖向填充过后，要填充的矩阵缩小，因此我们修改矩阵的四点坐标（右上角为坐标起点(0,0)）四点坐标分别为(min_i, min_j)、(min_i, max_j)、（max_i, max_j)、(max_i, min_j)然后进行下一方向填充。即可得到结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#define LEFT 0#define RIGHT 1#define UP 2#define DOWN 3using namespace std;int main(){ int N, m, n; cin &gt;&gt; N; vector&lt;int&gt; v(N); for (int i = 0; i &lt; N; i++) cin &gt;&gt; v[i]; m = n = sqrt(N); while (m * n != N) { if (m * n &gt; N) n--; else m++; } sort(v.begin(), v.end()); vector&lt;vector&lt;int&gt;&gt; res(m, vector&lt;int&gt;(n)); int state = RIGHT; int max_i = m - 1, max_j = n - 1, min_i = 0, min_j = 0, i = 0, j = 0; for (int k = N - 1; k &gt;= 0; k--) { int temp = v[k]; switch (state) { case LEFT: if (j == min_j) { state = UP; max_i--; res[i--][j] = temp; } else res[i][j--] = temp; break; case RIGHT: if (j == max_j) { state = DOWN; min_i++; res[i++][j] = temp; } else res[i][j++] = temp; break; case UP: if (i == min_i) { state = RIGHT; min_j++; res[i][j++] = temp; } else res[i--][j] = temp; break; case DOWN: if (i == max_i) { state = LEFT; max_j--; res[i][j--] = temp; } else res[i++][j] = temp; break; } } for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) cout &lt;&lt; res[i][j] &lt;&lt; ((j == n - 1) ? \"\\n\" : \" \"); return 0;}","link":"/2020/08/18/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-25%E5%88%86-PAT%E4%B9%99%E7%BA%A7/"},{"title":"1042.字符统计(20)-PAT乙级","text":"请编写程序，找出一段给定文字中出现最频繁的那个英文字母。 输入格式：输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。 输出格式：在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。 输入样例：1This is a simple TEST. There ARE numbers and other symbols 1&amp;2&amp;3........... 输出样例：1e 7 分析：用int a[26]做哈希表，遍历字符串k=tolower(str[i])-‘a’，得到字母下标k（a对应0，z对应25），下标不在[0,25]判断不为字母舍去，之后a[k]++。遍历哈希表a，max=0，当a[max]&gt;a[i]时记录max=i。（因为是&gt;不是&gt;=遇到同样数目字符时，max记录的是ascii码靠前的字符） 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ string str; getline(cin, str); int a[26]; memset(a, 0, sizeof(a)); int max = 0; for (size_t i = 0; i &lt; str.length(); i++) { int k = tolower(str[i]) - 'a'; if (k &lt; 0 || k &gt; 25) continue; a[k]++; } for (size_t i = 0; i &lt; 26; i++) { if (a[i] &gt; a[max]) max = i; } cout &lt;&lt; (char)(max + 'a') &lt;&lt; \" \" &lt;&lt; a[max] &lt;&lt; endl; return 0;} ==注：如果将找出最大值放进第一个for循环可能会造成max指向相同数目但ascii码不靠前的字符==","link":"/2020/08/15/1042-%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1-20-PAT%E4%B9%99%E7%BA%A7/"},{"title":"用N1搭建家用NAS","text":"久闻N1大名，去年冬天入手了一台用来做电视盒子表现很不错。最近有想写博客的想法，就想再来一台用以做博客的服务器。但当N1到手后发觉没有公网IP，盒子也就只能工作在局域网，无法通过公网访问博客。所以转换思路用hexo写博客挂在GitHub Pages上也是不错的。那N1呢？没有公网IP索性就刷成Armbian，在Arm Linux上搭建家用NAS吧（顺带Linux也可以跑一些python脚本）。 一.降级并刷入ArmbianArmbian是适用与Arm平台的嵌入式Debian，是一个Arm Linux常见的硬件载体有各种Pi（比如树莓派、香橙派） 1.降级[工具原作者]: 链接: https://www.right.com.cn/forum/thread-340279-1-1.html [降级工具]: 链接: https://pan.baidu.com/s/1sxMs5Gut4472g9vI_KGppQ 提取码: 2vgk N1连接网络，在盒子上用鼠标连续点击版本号开启ADB，开启后打开降级工具选在2-N1降级按照提示输入相应IP，降级成功后就先不用管。如果失败就多试几次。 补充：如果没有USB双公头线，那么将无法通过webpad降级工具的功能3）触发U盘启动。 替代方法是下载adb工具，然后执行如下2个命令，即可确保支持U盘启动： adb connect 斐讯IP adb shell reboot update 2.刷入Armbian[Armbian系统]: 链接: https://pan.baidu.com/s/13ogx4QHFu_V4nYdhBuIoPA 提取码: bwy4 写入U盘降级成功后拔掉盒子电源，往U盘中写入Armbian系统，用烧录工具进行写入。写入后将 1meson-gxl-s905d-phicomm-n1-xiangsm.dtb 放进U盘中dtb目录下，在dtb同级目录下修改uEnv.ini为 1dtb_name=/dtb/meson-gxl-s905d-phicomm-n1-xiangsm.dtb 其余配置不用改。dtb为引导文件，引导不同的硬件配置以不同的方式启动Armbian，此处修改为N1的dtb是为了引导N1启动系统。 dtb文件作用的描述是，使用dtb可以减少linux内核版本的数量。同一份linux 内核代码可以在多个板卡上运行，每个板卡可以使用自己的dtb文件 百度dtb解释 启动并配置然后插入U盘接通N1电源（不要在N1开机状态下插入U盘，安卓系统会往U盘里写一些东西，后会出现一些异常）插上网线，然后在windows用xshell或其它终端用ssh登陆N1的Armbian系统，登陆格式为 1ssh root@ip(N1在网络下的ip，可以去路由器查看) -p 22（端口，如果不行请用ScanPort扫描出端口） 密码为1234，进去系统后会询问一次密码再次输入即可。输入后，会提示修改密码，修改即可，按照提示创建新用户照着提示做就行。 armbian-config命令进入配置 选择Personal 修改时区为Asia/Chongqing或Shanghai 修改Mirror为清华源，hostname可以根据自己喜好修改主机名 连接WiFi输入nmtui配置WiFi（非必须步骤，可选），选择第二项Activate a connection进入后连接WiFi即可，若出现扫描不出WiFi可能是U盘内容出错，重新写U盘从头再做一遍。 apt换源默认apt官方源因为一些原因速度较慢，所以换源采用清华源。输入vim /etc/apt/sources.list，更换里面内容为 12345678deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse#deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse#deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse#deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse#deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse 修改apt源，输入vim /etc/apt/sources.list.d/armbian.list，修改内容为 1deb https://mirrors.tuna.tsinghua.edu.cn/armbian bionic main bionic-utils bionic-desktop 之后执行 12apt updateapt upgrade 写入emmc（可选）如果不写入emmc系统会一直处于U盘中，写入的话可以脱离U盘。 1nand–sata-install 命令写入U盘，完成后输入halt关机，再次开机拔掉U盘就可以正常进入系统。 其余配置建议更换sh为zsh，apt install zsh再去下载oh-my-zsh，vim ~/.zshrc修改主题为ys 二.安装OMV并配置SMB1.安装OMVOMV全称OpenMediaVault，一款开源NAS系统。 SMB换句话说，就是一个围绕局域网共享存储文件或文件夹的一个服务。 SMB概念： SMB(全称是Server Message Block)是一个协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。SMB最初是IBM的贝瑞·费根鲍姆（Barry Feigenbaum）研制的，其目的是将DOS操作系统中的本地文件接口“中断13”改造为网络文件系统。 一条命令安装OMV5 1wget -O - https://github.com/OpenMediaVault-Plugin-Developers/installScript/raw/master/install | sudo bash 安装成功后可以浏览器进入盒子IP，账户默认admin，密码默认为openmediavault。此处安装的OMV开机自动启动。 2.配置SMB挂载U盘 共享文件夹选择刚才挂载的U盘，填入名称自动生成文件夹，按照需求配置权限。 SMB添加共享文件夹如图操作，选择刚才生成的共享文件夹按照需求配置权限。 至此，SMB成功。 成功后即可在局域网内管理文件。 三.配置一些定时脚本有了SMB功能后，得益于 Linux的强大，我们可以用python写一些脚本定时执行。 若用python3执行脚本，应使用pip3安装某些可能用的包，apt下应该这样安装 1sudo apt install python3-pip pip安装成功后就可以安装一些python的包了 1pip3 install numpy(包名) crontab是Linux的定时任务，输入crontab -e即可编辑定时任务 参数列表： -e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe) -r : 删除目前的时程表 -l : 列出目前的时程表 从左到右定时任务格式为 12345678* * * * *- - - - -| | | | || | | | +----- 星期中星期几 (0 - 7) (星期天 为0)| | | +---------- 月份 (1 - 12) | | +--------------- 一个月中的第几天 (1 - 31)| +-------------------- 小时 (0 - 23)+------------------------- 分钟 (0 - 59) 比如说我要在每天的00:00执行某个python脚本可以 crontab详细请参照菜鸟教程 https://www.runoob.com/linux/linux-comm-crontab.html 贴吧自动签到python脚本，签到成功发送邮件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import smtplibimport requestsimport refrom email import encodersfrom email.mime.text import MIMETextfrom email.mime.base import MIMEBasefrom email.mime.multipart import MIMEMultipartfrom datetime import dateclass AutoSign: def __init__(self, d=[]): #d[0]存放cookie #d[1]要发送的邮箱 m = self.signin(d[0]) if len(d) == 2: mail = d[1] self.send2mail([ '',#发送邮件的发送邮箱 '',#发送邮箱的授权码 mail ], m) def send2mail(self, s=[], m=''): receivers = [] sender = s[0] passWord = s[1] receivers.append(s[2]) msg = MIMEMultipart() today = str(date.today()) msg['Subject'] = today+'贴吧自动签到' msg['From'] = '贴吧自动签到' msg_content = m msg.attach(MIMEText(msg_content, 'plain', 'utf-8')) try: #QQsmtp服务器的端口号为465或587 s = smtplib.SMTP_SSL(\"smtp.qq.com\", 465) s.set_debuglevel(1) s.login(sender, passWord) #给receivers列表中的联系人逐个发送邮件 for item in receivers: msg['To'] = to = item s.sendmail(sender, to, msg.as_string()) print('Success!') s.quit() print(\"All emails have been sent over!\") except smtplib.SMTPException as e: print(\"Falied,%s\", e) def signin(self, cookie): s = '' print('*' * 30 + '百度贴吧签到小助手' + '*' * 30) # 例如 cookie = 'xxxxxxxxxxx' url = 'https://tieba.baidu.com/' headers = { 'Cookie': cookie, 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36' } html = requests.get(url, headers=headers).text tieba = re.findall(r'forum_name\":\"(.*?)\"', html) tieba = tieba[:int(len(tieba) / 2)] print('正在进行贴吧签到...') num = 0 k = 0 for i in tieba: i = i.replace('\\\\\\\\', '\\\\').encode( 'latin-1').decode('unicode_escape') url = 'http://tieba.baidu.com/sign/add' form = {'ie': 'utf-8', 'kw': i, # 要签到的贴吧名 'tbs': '9da208cc747e7b5b1519730458'} html = requests.post(url, data=form, headers=headers).json() if html['no'] == 1101: k += 1 print('[' + i + '吧]:' + '亲，此贴吧您之前已经签过了哦!') t = str(int(k/10))+str(k % 10)+' . [ '+i+' 吧] : ' s += \"{}已签，无须再签\".format(t.ljust(30)) s += '\\n' if html['error'] == '' or html['no'] == 0: k += 1 print('[' + i + '吧]:' + '签到成功!') t = str(k)+' . \\t[ '+i+' 吧] :\\t' s += (\"{}: 签到成功\".format(t.ljust(30))) s += '\\n' num += 1 print('\\n') r = '本次签到情况: '+str(num)+\" / \"+str(k) s = r+\"\\n\\n\"+s # print(s) return sif __name__ == '__main__': user = AutoSign([ '',#贴吧账户cookie，浏览器获取 ''#接收签到信息邮箱 ]) 本文参考链接 有疑问？在博客主页点击关注我进入我的知乎主页","link":"/2020/04/11/%E7%94%A8N1%E6%90%AD%E5%BB%BA%E5%AE%B6%E7%94%A8NAS/"},{"title":"约瑟夫环","text":"据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 问题描述：N个人围成一圈，从第K个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，K=1，M=5，被杀掉的顺序是：5，4，6，2，3。输入N, K, M，输出出环序列。 思路：用数组a来标记是否已经出环，默认0出环标记-1。开始从第K人报数，若报M出环标记不参与下次报数。 数组实现，链表实现原理相同。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int main(){ int N, K, M; cin &gt;&gt; N &gt;&gt; K &gt;&gt; M; int *a = new int[N + 1]; fill(a, a + N + 1, 0); //num为约瑟夫环剩余人数，count为所报数 int p = K, count = 0, num = N; while (num) { //未出环的人参与报数，当count是M时出环 if (a[p] != -1 &amp;&amp; ++count == M) { count = 0; a[p] = -1; //将已出环的人标记为-1 num--; cout &lt;&lt; p &lt;&lt; \" \"; } p++; //指针指向下一个人 p = (p - 1) % N + 1; //p范围转成[1,N] } return 0;} 链表实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;struct Node{ int n; Node *next;};int main(){ int N, K, M; cin &gt;&gt; N &gt;&gt; K &gt;&gt; M; Node *head, *node, *p; head = new Node; head-&gt;next = NULL; p = head; int num = N, count = 0; for (size_t i = 0; i &lt; N; i++) { node = new Node; node-&gt;n = K; p-&gt;next = node; p = node; K++; K = (K - 1) % N + 1; } p-&gt;next = head-&gt;next; delete head; while (num) { if (++count == M) { count = 0; Node *t = p-&gt;next-&gt;next; cout &lt;&lt; p-&gt;next-&gt;n &lt;&lt; \" \"; delete p-&gt;next; p-&gt;next = t; num--; } else p = p-&gt;next; } return 0;}","link":"/2020/08/14/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"title":"1059 C语言竞赛 (20分)-PAT乙级","text":"C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽： 0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。 1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！ 2、其他人将得到巧克力。 给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。 输入格式：输入第一行给出一个正整数 N（≤104），是参赛者人数。随后 N 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 K 以及 K 个需要查询的 ID。 输出格式：对每个要查询的 ID，在一行中输出 ID: 奖品，其中奖品或者是 Mystery Award（神秘大奖）、或者是 Minion（小黄人）、或者是 Chocolate（巧克力）。如果所查 ID 根本不在排名里，打印 Are you kidding?（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 ID: Checked（不能多吃多占）。 输入样例：123456789101112131461111666688881234555500016888800011111222288882222 输出样例：1234568888: Minion0001: Chocolate1111: Mystery Award2222: Are you kidding?8888: Checked2222: Are you kidding? 分析：建立结构体数组，用数组下标做参赛者ID的散列表，结构体中no代表排名默认为0（即没名次），is_checked为是否已经领取礼品默认为false。按照题目要求对第二组输入的ID进行判断，已经领取的is_checked=true，若no=0即没有名次则判定为ID不在排名内。判断素数函数若参数a==1则返回false，其余只需判断a在[2, sqrt(a)]范围内能被整除则不为素数，否则为素数。 ==注意：输出的参赛者ID应为4位数，不足位应在数字前补0，可用printf(“%04d”,id)实现== 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;struct S{ int no = 0; bool is_checked = false;};bool is_prime(int a){ if (a &lt;= 1) return false; for (int i = 2; i * i &lt;= a; i++) { if (a % i == 0) return false; } return true;}int main(){ int n, k, id; S s[10000]; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;id); s[id].no = i + 1; } scanf(\"%d\", &amp;k); for (int i = 0; i &lt; k; i++) { scanf(\"%d\", &amp;id); printf(\"%04d: \", id); if (s[id].no == 0) printf(\"Are you kidding?\\n\"); else if (s[id].is_checked) printf(\"Checked\\n\"); else if (s[id].no == 1) printf(\"Mystery Award\\n\"); else if (is_prime(s[id].no)) printf(\"Minion\\n\"); else printf(\"Chocolate\\n\"); s[id].is_checked = true; } return 0;}","link":"/2020/08/21/1059-C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B-20%E5%88%86-PAT%E4%B9%99%E7%BA%A7/"},{"title":"1135-Is It A Red-Black Tree-30分-PAT甲级","text":"1135.Is It A Red-Black Tree (30point(s)) There is a kind of balanced binary search tree named red-black tree in the data structure. It has the following 5 properties: (1) Every node is either red or black. (2) The root is black. (3) Every leaf (NULL) is black. (4) If a node is red, then both its children are black. (5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes. For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not. Figure 1 Figure 2 Figure 3 For each given binary search tree, you are supposed to tell if it is a legal red-black tree. Input Specification:Each input file contains several test cases. The first line gives a positive integer K (≤30) which is the total number of cases. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3. Output Specification:For each test case, print in a line “Yes” if the given tree is a red-black tree, or “No” if not. Sample Input:1234567397 -2 1 5 -4 -11 8 14 -15911 -2 1 -7 5 -4 8 14 -15810 -7 5 -6 8 15 -11 17 Sample Output:123YesNoNo 分析： 这道题一开始使用先序不建树测试点1过不去，找了好久问题发现==不建树不适合有重复节点的树==，这是因为不建树去遍历一棵树时中序序列的下标并不是唯一的，会导致子树的划分出现错误，从而陷入无限循环，提交代码测试点1段错误，由此推断测试点1数据可能有重复节点。 建树AC，先建树再DFS遍历树，judgeRBT两个参数分别是，root与父节点颜色par_color。使用par_color将连续两个节点是否都为红色与根节是否红色合成一个判断条件，初始将父节点的颜色设置为-1即红色，如果根节点为红色则is2Red为true即有两个连续的红色则不为二叉树。记录每一条path上黑色节点的数目bnode，当到达叶子节点时将bnode黑色节点数目插入一个set即isRep，若所有path的bnode一致，则set的大小最终为1。最终DFS遍历完一棵树，得到is2Red与isRep.size()。is2Red==false&amp;&amp;isRep.size()==1时说明是一颗红黑树输出Yes。 建树AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; isRep; //用来判断所有路径黑色节点个数是否一定vector&lt;int&gt; pre;int bnode, n, is2Red; //bnode记录某一路径黑色节点数,is2Red是否有两个连续的红色父子struct Node{ int data; Node *lchild, *rchild; Node(int x) : data(x), lchild(NULL), rchild(NULL){};};void build(Node *&amp;root, int v){ if (root == NULL) root = new Node(v); else if (abs(v) &lt;= abs(root-&gt;data)) create(root-&gt;lchild, v); else create(root-&gt;rchild, v);}void judgeRBT(Node *root, int par_color){ if (root == NULL) { isRep.insert(bnode); return; } if (root-&gt;data &lt; 0 &amp;&amp; par_color &lt; 0) is2Red = true; if (root-&gt;data &gt; 0) bnode++; judgeRBT(root-&gt;lchild, root-&gt;data); judgeRBT(root-&gt;rchild, root-&gt;data); if (root-&gt;data &gt; 0) bnode--;}int main(){ int k; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { scanf(\"%d\", &amp;n); isRep.clear(); is2Red = false; bnode = 0; pre.resize(n); Node *root = NULL; for (int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;pre[j]); build(root, pre[j]); } judgeRBT(root, -1); //若父子节点无连续红色且各个路径黑色节点一定时输出Yes printf(\"%s\\n\", ((!is2Red &amp;&amp; (isRep.size() == 1)) ? \"Yes\" : \"No\")); } return 0;} 不建树测试点1段错误代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;set&lt;int&gt; isRep; //用来判断所有路径黑色节点个数是否一定vector&lt;int&gt; pre, in;int bnode, n; //用来记录某一路径黑色节点数bool is2Red; //检测是否有两个连续红色void judgeRBTree(int par_color, int inl, int inr, int pre_root){ if (inl &lt;= inr) { if (par_color &lt; 0 &amp;&amp; pre[pre_root] &lt; 0) is2Red = true; int in_root = 0; while (pre[pre_root] != in[in_root]) in_root++; //如果左孩子是黑色则bnode++ if (inl &lt;= in_root - 1 &amp;&amp; pre[pre_root + 1] &gt; 0) bnode++; judgeRBTree(pre[pre_root], inl, in_root - 1, pre_root + 1); if (inl &lt;= in_root - 1 &amp;&amp; pre[pre_root + 1] &gt; 0) bnode--; //如果右孩子是黑色则bnode++ if (in_root + 1 &lt;= inr &amp;&amp; pre[in_root - inl + pre_root + 1] &gt; 0) bnode++; judgeRBTree(pre[pre_root], in_root + 1, inr, in_root - inl + pre_root + 1); if (in_root + 1 &lt;= inr &amp;&amp; pre[in_root - inl + pre_root + 1] &gt; 0) bnode--; } else { //将这一路径上的黑节点数插入rep isRep.insert(bnode); return; }}int main(){ int k; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { scanf(\"%d\", &amp;n); isRep.clear(); pre.resize(n); in.resize(n); is2Red = false; bnode = 0; for (int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;pre[j]); in[j] = pre[j]; } sort(in.begin(), in.end(), [](int a, int b) { return abs(a) &lt; abs(b); }); judgeRBTree(-1, 0, n - 1, 0); //若父子节点无连续红色且，各个路径黑色节点一定时输出Yes printf(\"%s\\n\", ((!is2Red &amp;&amp; (isRep.size() == 1)) ? \"Yes\" : \"No\")); } return 0;}","link":"/2020/11/10/1135-Is-It-A-Red-Black-Tree-30%E5%88%86-PAT%E7%94%B2%E7%BA%A7/"}],"tags":[{"name":"第一篇文章","slug":"第一篇文章","link":"/tags/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"},{"name":"PAT乙级","slug":"PAT乙级","link":"/tags/PAT%E4%B9%99%E7%BA%A7/"},{"name":"pat","slug":"pat","link":"/tags/pat/"},{"name":"N1 NAS","slug":"N1-NAS","link":"/tags/N1-NAS/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"PAT甲级","slug":"PAT甲级","link":"/tags/PAT%E7%94%B2%E7%BA%A7/"}],"categories":[{"name":"记录","slug":"记录","link":"/categories/%E8%AE%B0%E5%BD%95/"},{"name":"N1","slug":"N1","link":"/categories/N1/"}]}